# tools/gen_hw_params.py
import os, json, glob
import numpy as np
import math

def q_format(x, frac_bits):
    return int(round(float(x) * (1 << frac_bits)))

def main(out_dir, q_frac_bits=8, logq_frac_bits=12):
    man_path = os.path.join(out_dir, "manifest.json")
    with open(man_path, "r") as f:
        manifest = json.load(f)

    C = int(manifest["num_classes"])
    alpha = float(manifest["alpha"])
    lut_paths = sorted(glob.glob(os.path.join(out_dir, "luts", "lut_*.npy")))
    if not lut_paths:
        raise FileNotFoundError("No luts/*.npy found")

    max_count = 0
    for p in lut_paths[:min(8, len(lut_paths))]:  # generate upper bound
        tab = np.load(p)  # shape: (C, 2^m)
        max_count = max(max_count, int(tab.max()))
    COUNT_BITS = max(1, int(math.ceil(math.log2(max_count + 1))))

    DATA_WIDTH = C * COUNT_BITS
    ALPHA_Q = q_format(alpha, q_frac_bits)

    vh = f"""// Auto-generated by gen_hw_params.py
`ifndef HW_PARAMS_VH
`define HW_PARAMS_VH

`define C                {C}
`define COUNT_BITS       {COUNT_BITS}
`define DATA_WIDTH       {DATA_WIDTH}

// fixed-point for (count + alpha): count is integer, alpha is Q{q_frac_bits}
`define ALPHA_Q          {ALPHA_Q}
`define ALPHA_FRAC_BITS  {q_frac_bits}

// fixed-point for log outputs (Q{logq_frac_bits})
`define LOGQ_FRAC_BITS   {logq_frac_bits}

`endif // HW_PARAMS_VH
"""
    with open(os.path.join(out_dir, "hw_params.vh"), "w") as f:
        f.write(vh)
    print(f"[OK] Wrote hw_params.vh  (C={C}, COUNT_BITS={COUNT_BITS}, DATA_WIDTH={DATA_WIDTH}, ALPHA_Q={ALPHA_Q})")

if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument("--out_dir", required=True, help="export directory")
    ap.add_argument("--alpha_q_frac", type=int, default=8)
    ap.add_argument("--logq_frac", type=int, default=12)
    args = ap.parse_args()
    main(args.out_dir, q_frac_bits=args.alpha_q_frac, logq_frac_bits=args.logq_frac)
